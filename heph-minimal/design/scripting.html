<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/strict.dtd" >
<html lang="en" xmlns="http://www.w3.org/TR/xhtml1">
<head>
<title>Mark Hughes: Hephaestus Scripting</title>
</head>
<body bgcolor="#ccffcc" text="#000000" link="#0000ff" vlink="#990099" alink="#ff0000">

<table width="100%">
<tr><td><a href="http://kuoi.asui.uidaho.edu/~kamikaze/Hephaestus/"><img src="../images/icon/hephaestus.gif" width="40" height="40" border="1" /></a></td>
<td><h1 align="center">Hephaestus Scripting</h1>
<h4 align="center">Copyright &copy; 2001 by Mark Hughes &lt;<a href="mailto:kamikaze@kuoi.asui.uidaho.edu">kamikaze@kuoi.asui.uidaho.edu</a>&gt;</h4>
</td></tr>
</table>

<dl>
<dt><img src="../images/icon/hammer.gif" width="16" height="10" alt="*" />
    <a href="../index.html">Hephaestus</a></dt>
<dt><img src="../images/icon/hammer.gif" width="16" height="10" alt="*" />
    <a href="../gameplay.html">Gameplay</a></dt>
<dt><img src="../images/icon/hammer.gif" width="16" height="10" alt="*" />
    <a href="../adventures.html">Adventures</a></dt>
<dt><img src="../images/icon/hammer.gif" width="16" height="10" alt="*" />
    <a href="../faq.html">FAQ</a></dt>
<dt><img src="../images/icon/hammer.gif" width="16" height="10" alt="*" />
    <a href="index.html">Designing Adventures</a></dt>
    <dd><img src="../images/icon/hammer.gif" width="16" height="10" alt="*" />
        <a href="minimal.html">Minimal Language Specification</a></dd>
    <dd><img src="../images/icon/hammer.gif" width="16" height="10" alt="*" />
        Scripting</dd>
    <dd><img src="../images/icon/hammer.gif" width="16" height="10" alt="*" />
        <a href="art.html">Art</a></dd>
    <dd><img src="../images/icon/hammer.gif" width="16" height="10" alt="*" />
        <a href="sound.html">Sound</a></dd>
    <dd><img src="../images/icon/hammer.gif" width="16" height="10" alt="*" />
        <a href="pocket.html">Tutorial: DESTROY ALL POCKET MONSTERS!</a></dd>
</dl>
<br clear="right" />

<p>
&lt;<a href="#scripting">Scripting</a>&gt;
&lt;<a href="#objects">Objects</a>&gt;
&lt;<a href="#scripting_constants">Scripting Constants</a>&gt;
&lt;<a href="#scripting_functions">Scripting Functions</a>&gt;
&lt;<a href="#graphics_functions">Graphics Functions</a>&gt;
</p>

<p><hr /></p>
<h2><a name="objects">Objects</a></h2>

<p>Objects in Hephaestus have an inheritance hierarchy, shown in the tree
below; nested objects inherit from the next level up.  Thus, any command that
says it applies to a Thing will also apply to a Block, Item, or Entity.  Any
command that says it applies to an Entity will also apply to a Creature or the
Player.</p>

<ul>
<li>Stuff: everything you can refer to with an id
    <ul>
    <li>Map: a 2D map of Grids.</li>
    <li>Terrain: the definition of a terrain type, used by a Grid.</li>
    <li>Thing: anything that can appear on a Map
        <ul>
        <li>Block: a Thing that cannot be carried.</li>
        <li>Statted: a Thing with stats
            <ul>
            <li>Item: a Thing that can be taken by the Player.</li>
            <li>Entity: a living Thing.
                <ul>
                <li>Creature: a non-player Entity, with some form of AI.</li>
                <li>Player: your character.  Always id "player", and there is
                currently only ever one Player.</li>
                </ul></li>
            </ul></li>
        </ul></li>
    </ul></li>
<li>Grid: a single map square with terrain type and contents.  Grids are not
"Stuff"; you can only refer to them by map id and coordinate.</li>
</ul>


<p><hr /></p>
<h2><a name="scripting_constants">Scripting Constants</a></h2>

<p>A number of global variables are defined for use as constants; it would be a
bad idea to change any of them.</p>

<dl>
<dt><b>GAMETURN</b></dt>
    <dd>The number of turns since the adventure started.  If you assume that
    each turn is 1 game-world minute, there are 1440 minutes in a day, so you
    could use '<code>int(div(GAMETURN,1440))</code>' to tell you how many days
    since the game started, and '<code>int(div(mod(GAMETURN,1440),60))</code>'
    to give you the hour of the current day.</dd>

<dt><b>VIEW_DIST</b></dt>
    <dd>The number of grids from the center of the view to the edge - it's
    currently 5, but you should use the constant, as it may change someday.
    </dd>

<dt><b>VIEW_TILES</b></dt>
    <dd>The number of grids across the view - VIEW_DIST*2+1, or currently 11.
    </dd>

<dt><b>TILE_SIZE</b></dt>
    <dd>The size of a grid in pixels, currently 48.  Mainly used in
    <a href="#graphics_functions">graphics functions</a>.
    </dd>

<dt><b>VIEW_SIZE</b></dt>
    <dd>The size of the view in pixels - VIEW_DIST*TILE_SIZE, or currently 528.
    Mainly used in <a href="#graphics_functions">graphics functions</a>.
    </dd>


<dt><b>North</b></dt>
<dt><b>East</b></dt>
<dt><b>South</b></dt>
<dt><b>West</b></dt>
    <dd>Values of the four directions.  Note that directions are 0-indexed.
    </dd>

<dt><b>NDIRS</b></dt>
    <dd>The total number of directions - 4 (1 higher than West), but it's much
    better to use NDIRS instead of wondering why you wrote '4' when you fix your
    code some months later.
    </dd>

<dt><b>DIR_ABBV$[]</b></dt>
    <dd>The first letter of each direction - "n" for North, etc.
    </dd>

<dt><b>DIR_NAME$[]</b></dt>
    <dd>The full name of each direction - "north" for North, etc.
    </dd>

<dt><b>DIR_DX[]</b></dt>
<dt><b>DIR_DY[]</b></dt>
    <dd>The "delta" (amount to add to your current coordinate) to move in each
    direction - North moves you up (to a lower y-coordinate), so DIR_DX[North]
    is 0, DIR_DY[North] is -1.
    </dd>


<dt><b>LAYER_Under</b></dt>
<dt><b>LAYER_Over</b></dt>
    <dd>Values for terrain layers - see the 'ter_' functions below.
    </dd>


<dt><b>OPA_None</b></dt>
<dt><b>OPA_Partial</b></dt>
<dt><b>OPA_Full</b></dt>
    <dd>Opacity values - see 'ter_opa()' and 'th_opa()' functions below.
    </dd>


<dt><b>TYPE_Map</b></dt>
<dt><b>TYPE_Block</b></dt>
<dt><b>TYPE_Item</b></dt>
<dt><b>TYPE_Creature</b></dt>
<dt><b>TYPE_Player</b></dt>
    <dd>The values returned by 'st_exists()' to indicate the type of a Stuff.
    </dd>


<dt><b>ST_Body</b></dt>
<dt><b>ST_Speed</b></dt>
<dt><b>ST_Mind</b></dt>
<dt><b>ST_Presence</b></dt>
<dt><b>ST_HitPoints</b></dt>
<dt><b>ST_MagicPoints</b></dt>
<dt><b>ST_Attack</b></dt>
<dt><b>ST_Evade</b></dt>
<dt><b>ST_Defense</b></dt>
<dt><b>ST_Range</b></dt>
<dt><b>ST_MagicAbility</b></dt>
<dt><b>ST_MagicEvade</b></dt>
<dt><b>ST_MagicDefense</b></dt>
    <dd>Index numbers for each stat, used by 'th_stat()' functions below.  See
    <a href="../gameplay.html">Gameplay</a> for an explanation.  Note that the
    stats are 0-indexed.
    </dd>

<dt><b>NSTATS</b></dt>
    <dd>The total number of stats - this is 1 higher than ST_MagicDefense.
    </dd>

<dt><b>STAT_ABBV$[]</b></dt>
    <dd>The 2-letter stat abbreviation - STAT_ABBV$[ST_Body] is "Bo", etc.
    </dd>

<dt><b>STAT_NAME$[]</b></dt>
    <dd>The full name of each stat - STAT_NAME$[ST_Body] is "Body", etc.
    </dd>


<dt><b>EQ_Weapon</b></dt>
<dt><b>EQ_Shield</b></dt>
<dt><b>EQ_Armor</b></dt>
<dt><b>EQ_Hat</b></dt>
<dt><b>EQ_Accessory</b></dt>
    <dd>Index numbers for each equipment position.  Note that these are
    0-indexed.
    </dd>

<dt><b>NEQUIP</b></dt>
    <dd>The total number of equipment positions - 1 higher than EQ_Accessory.
    </dd>

<dt><b>EQUIP_NAME$[]</b></dt>
    <dd>The full name of each equipment position - EQUIP_NAME$[EQ_Weapon] is
    "Weapon".
    </dd>

</dl>


<p><hr /></p>
<h2><a name="scripting_functions">Scripting Functions</a></h2>
<ul>
<li>The mdh.hephaestus.scripting library is automatically loaded when you start
Hephaestus, and it will not load any other libraries, so adventure files are
safe to share with others.</li>

<li>Unless specifically stated otherwise, all coordinates and indices from these
functions are 0-based.
</li>

<li>Callback functions ("func()" arguments below) are not evaluated immediately
as functions usually are.  All variables in the callback are replaced with their
current values, but any argument functions are not evaluated, and the entire
function is stored for later use.  This allows you to pass in calculated
information.  So, say you have this code:
<pre>
def(makeTeleporter(mapid$, x, y, xdest, ydest))
    let(id$, tempid$())
    bl_new(id$, "")
    th_moveto(id$, mapid$, x, y)
    # teleportTarget is the callback function!
    st_trigger(id$, teleportTarget(mapid$, xdest, ydest, sub(rnd(NDIRS),1)))
    ;
</pre>
    <p>If you call this function with
    '<code>makeTeleporter("test_M",1,1, 9,9)</code>', the callback is stored in
    the Block as '<code>teleportTarget("test_M",9,9,sub(rnd(4),1))</code>'.
    Notice that the sub() and rnd() functions aren't evaluated just yet, but
    NDIRS is.</p>

    <p>Callbacks are one of the most powerful features in Hephaestus, and you
    can't really build much without them, so take the time to experiment with
    them and get used to using them.</p>
</li>

</ul>

<hr noshade="noshade" width="50%" align="left" />
<dl>
<dt><b><a name="alert">alert</a>(title$, text$, buttons$, defaultbtn, cancelbtn {, iconfile$})</b></dt>
    <dd>Displays an alert box, with the given 'title$' and 'text$'.  'text$' can
    contain newlines ('\n').  'button$' is a string containing the labels for
    the buttons, each separated by a '|' character (i.e.
    <code>"OK|Cancel"</code>).  'defaultbtn' and 'cancelbtn' are the buttons
    (1-based) which will be activated when the user hits Enter or Escape,
    respectively.  If 'iconfile$' is specified, that image is shown at the top
    left side of the dialog (you must give the full filename) - this might be a
    system icon ("images/icons/question.gif", etc.) or a character's portrait.
    Returns the index (1-based) of the button chosen.
    </dd>

<dt><b><a name="bl_new">bl_new</a>(id$, name$)</b></dt>
    <dd>Creates a new Block.  Returns 1.
    </dd>

<dt><b><a name="cr_brain">cr_brain</a>(id$, brain$)</b></dt>
    <dd>Sets the brain of a Creature.  Brains are predesigned, and generally
    very stupid, AI routines for a Creature.  Most brains allow a Creature to
    attack anyone they don't like, if they are within range.  The default is no
    brain (rather like marketing staff).  See also
    '<code><a href="#cr_think">cr_think()</a></code>'.  Returns 1.
    <dl>
    <dt>"" = no brain</dt>
        <dd>No-brainers do not move or attack.</dd>
    <dt>"g" = guard</dt>
        <dd>Guards do not move, but do attack.  They will not leave their
        posts to chase after enemies.  The guard brain is also useful if you
        want to move a Creature in its en_turn() callback - you move it around,
        and it'll do its own fighting.</dd>
    <dt>"s" = static</dt>
        <dd>Static do not move, but do attack.  If they are attacked, they
        become brain "h".</dd>
    <dt>"r" = random</dt>
        <dd>Move randomly like drunken frat boys, and attack anything nearby
        (also like drunken frat boys).  If they are attacked, they become brain
        "h".  They have a 7/12 chance of moving forward, a 2/12 chance each of
        moving left or right, and a 1/12 chance of moving backwards.</dd>
    <dt>"h" = hunts player</dt>
        <dd>Move in a straight line towards the player, and attack whenever
        possible.  Hunters are fairly stupid, so it's easy to get them
        trapped.</dd>
    <dt>"a" = avoids player</dt>
        <dd>Move in a straight line away from the player, and attack only if
        there is no escape move possible.  If attacked, avoiders become
        brain "r" - so they can become hunters in just two attacks!</dd>
    <dt>"p&lt;sequence&gt;" = programmed</dt>
        <dd>Programmed to move in a preset pattern, and will not deviate from
        it.  They will attack if possible.  Each character of the sequence
        is a single turn's action.  If they cannot perform the action this
        turn, they will wait and try again next turn.
<pre>
p = Pause
n = North
e = East
s = South
w = West
t = Trigger Here
0-9 = Change pose
</pre>
        </dd>
    </dl>
    </dd>

<dt><b><a name="cr_defeat">cr_defeat</a>(id$, func())</b></dt>
    <dd>Sets the defeat function of a Creature.  When the Creature is defeated
    in combat, this function will be called instead of the usual "You have
    slain" message; 'actorid$' will contain the killer's id, and 'targetid$'
    will contain this Creature's id.  This is useful for boss monsters who
    "escape" at the end of a combat, or who have some dying words, or who just
    drop some items when they die.  The player still receives gold and exp for
    the fight.  To disable the defeat function, set it to 0:
    '<code>cr_defeat(id$, 0)</code>'.  Returns 1.
    </dd>

<dt><b><a name="cr_faction">cr_faction</a>(id$, faction)</b></dt>
    <dd>Assigns a Creature to a given faction; 0 is the Player's faction, any
    other value is hostile to the player.  Creatures are hostile to all
    factions other than their own (so you can have Creatures fight each other by
    giving them different factions).  The default is faction 1.  Returns 1.
    </dd>

<dt><b><a name="cr_get_brain$">cr_get_brain$</a>(id$)</b></dt>
    <dd>Returns the current brain of a Creature.  See
    '<code><a href="#cr_brain">cr_brain()</a></code>'.</dd>

<dt><b><a name="cr_get_faction">cr_get_faction</a>(id$)</b></dt>
    <dd>Returns the faction of a Creature.  See
    '<code><a href="#cr_faction">cr_faction()</a></code>'.
    </dd>

<dt><b><a name="cr_selfdefense">cr_selfdefense</a>(id$)</b></dt>
    <dd>Creature 'id$' attempts to find an enemy to attack in the list
    'enemies$[]'; the first one in range and a direct line of sight will be
    attacked.  Normally '<code><a
    href="#cr_selfdefense">cr_selfdefense()</a></code>' is only called from a
    think function, where 'enemies$[]' is constructed for you - see '<code><a
    href="#cr_think">cr_think()</a></code>'.  Returns 1 if an enemy was found,
    0 if not.
    </dd>

<dt><b><a name="cr_think">cr_think</a>(id$, func())</b></dt>
    <dd>Sets the AI thinking function of a Creature.  This callback is called
    every turn, and you can evaluate the situation and call the various
    en_do_...() functions or
    '<code><a href="#cr_self_defense">cr_self_defense()</a></code>' to perform
    actions.  There are three global variables set before the think function is
    called: 'actorid$' contains the id of this Creature.  'friend$[]' is a list
    (indexed by number) of all friendly Entities in sight, and 'enemies$[]' is a
    list (indexed by number) of all hostile Entities in sight.</p>

    <p>The callback function should return 1 if the Creature did anything, or 0
    if not.</p>

    <p>To make an AI that behaves like the "brain" AIs, the Creature must make a
    Speed roll before moving, but after checking for combat, because all
    Creatures can attack every turn, but anything with a Speed under 20 is not
    guaranteed to move every turn.</p>
<pre>
# AI to wander in circles
# thinkCircles(1) turns right when blocked, thinkCircles(-1) turns left
def(thinkCircles(turn))
    # check for self-defense
    if(cr_selfdefense(actorid$), return(1))
    # make a Speed roll to move
    if(le(th_task(actorid$, ST_Speed), 0), return(0))
    # now figure out where to move
    # try to move forward, return 1 if it worked.
    if(en_do_move(actorid$), return(1))
    # otherwise, turn left or right
    th_facing(actorid$, add(th_get_facing(actorid$),turn))
    return(0)
    ;
</pre>

    <p>Remember that <b>every</b> Creature on the current map, visible to the
    player or not, is checked for AI every single turn, so if you perform
    complex calculations on many Creatures, you will slow the turn update
    badly.</p>

    <p>To disable the think function, assign a standard-issue brain with
    '<code><a href="#cr_brain">cr_brain()</a></code>'.  Returns 1.</p>
    </dd>

<dt><b><a name="cr_new">cr_new</a>(id$, name$)</b></dt>
    <dd>Creates a new Creature.  Returns 1.
    </dd>

<dt><b><a name="d">d</a>(n, s)</b></dt>
    <dd>Returns the total of 'n' random numbers from 1 to 's' - this is
    equivalent to rolling 'n' 's'-sided dice, thus the function name.
    </dd>

<dt><b><a name="en_attack">en_attack</a>(id$, func())</b></dt>
    <dd>Entity 'id$' will call 'func' after every attack.  The id of this Entity
    will be in 'actorid$', the target will be in 'targetid$', and the amount the
    attack succeeded or failed by will be in 'attackresult'.  Returns 1.</dd>

<dt><b><a name="en_checkalive">en_checkalive</a>(id$, killerid$)</b></dt>
    <dd>Updates Entity 'id$' and checks to see if it is alive.  If not, the
    Entity is reported as killed by 'killerid$', or by nobody if 'killerid$' is
    "".  Returns 1 if alive, 0 if not.  You should call this after making any
    negative change to an Entity's HitPoints or primary stats (Body, Speed,
    Mind, or Presence).
    </dd>

<dt><b><a name="en_do_move">en_do_move</a>(id$)</b></dt>
    <dd>Entity 'id$' tries to move ahead, in the facing determined by
    '<code><a href="#th_facing">th_facing()</a></code>'.  If blocked by a
    hostile Entity, it will be attacked; if blocked by anything triggerable,
    it will be triggered.  Returns 1 if the move/attack/trigger was successful,
    0 if not.  'en_do_move()' is mostly used in
    '<code><a href="#cr_think">cr_think()</a></code>' AI routines.</dd>

<dt><b><a name="en_do_attack">en_do_attack</a>(id$)</b></dt>
    <dd>Entity 'id$' tries to attack ahead, in the facing determined by
    '<code><a href="#th_facing">th_facing()</a></code>'.  Unlike 'en_do_move()',
    'en_do_attack()' can make ranged attacks.  Returns 1 if the attack was
    successful, 0 if not.  'en_do_attack()' is mostly used in
    '<code><a href="#cr_think">cr_think()</a></code>' AI routines.</dd>

<dt><b><a name="en_do_magic">en_do_magic</a>(id$, magicname$)</b></dt>
    <dd>Entity 'id$' tries to cast a magic spell 'magicname$' ahead, in the
    facing determined by '<code><a href="#th_facing">th_facing()</a></code>'.
    Returns 1 if the spell was successful, 0 if not.  'en_do_magic()' is mostly
    used in '<code><a href="#cr_think">cr_think()</a></code>' AI routines.</dd>

<dt><b><a name="en_do_trigger">en_do_trigger</a>(id$)</b></dt>
    <dd>Entity 'id$' tries to trigger something in its current grid.  Returns 1
    if the trigger was successful, 0 if not.  'en_do_trigger()' is mostly used
    in '<code><a href="#cr_think">cr_think()</a></code>' AI routines.</dd>

<dt><b><a name="en_exp">en_exp</a>(id$, exp)</b></dt>
    <dd>Sets the experience of an Entity.  Creature experience is used as a
    reward when defeated by the Player.  Player experience is the current total
    of experience, which will be automatically spent to increase the player's
    level when it reaches (current level)&times;100 XP.  Returns 1.
    </dd>

<dt><b><a name="en_get_exp">en_get_exp</a>(id$)</b></dt>
    <dd>Returns the experience of an Entity.
    </dd>

<dt><b><a name="en_get_target$">en_get_target$</a>(id$, friendlyTarget, range)</b></dt>
    <dd>Returns the id of the first target visible ahead of Entity 'id$', or ""
    if no target is visible.  Only targets within 'range' (minimum 1) squares
    are found.  If 'friendlyTarget' is 0, only an enemy will be selected; if
    non-zero, only a friend will be selected.  You will usually use this in
    magic spells, in the form:
<pre>
global(targetid$,en_get_target(actorid$,0,5))
</pre>
    </dd>

<dt><b><a name="en_has_magic">en_has_magic</a>(id$, magicname$)</b></dt>
    <dd>Returns 1 if Entity 'id$' has a given magic spell 'magicname$', 0 if
    not.
    </dd>

<dt><b><a name="en_magattack">en_magattack</a>(id$, targetid$, dmg, youmsg$, tarmsg$)</b></dt>
    <dd>Entity 'id$' makes a magical attack on 'targetid$', with damage on a
    successful hit equal to 'dmg'.  'youmsg$' is used to report the attack's
    result to 'id$', 'tarmsg$' is used to report the attack's result to
    'targetid$'.  Returns 1 if the attack hit, even if it did no damage, 0 if it
    missed.  The messages will be followed by the results of the attack, but you
    must insert any names.  If you are sure that the actor or target will always
    be a creature, you can just use "" for their message.
<pre>
# Shoots a fire arrow doing damage equal to 25% of MagicAbility at a target
# ahead of you.
def(magicFireArrow())
    # Precondition: that there is a target ahead of you.
    global(targetid$,en_get_target$(actorid$, 0, 5))
    if(eq(targetid$,""), do(describe(join$("No enemy to ",
        DIR_NAME$[th_get_facing(actorid$)],".")),return(0)) )
    let(youmsg$,join$("You shoot an arrow of fire at ",st_get_name$(targetid$)))
    let(tarmsg$,join$(st_get_name$(actorid$)," shoots an arrow of fire at you"))
    let(dmg, mul(th_get_stat(actorid$,ST_MagicAbility),0.25))
    en_magattack(actorid$, targetid$, dmg, youmsg$, tarmsg$)
    ;
</pre>
    </dd>

<dt><b><a name="en_magic">en_magic</a>(id$, magic$, func())</b></dt>
    <dd>Gives Entity 'id$' a magic spell.  'magicname$' is the user's prompt,
    'func()' is the function called when the spell is invoked; the id of the
    Entity will be in 'actorid$'.  To remove a spell, set it to 0 instead of
    'func()'.  Returns 1.
    </dd>

<dt><b><a name="en_secondary">en_secondary</a>(id$)</b></dt>
    <dd>Calculates the standard "secondary stats" for an Entity, based on the
    "primary stats" (Body, Speed, Mind, Presence).  You can then adjust the
    stats further.  Returns 1.
<pre>
HitPoints = Body
MagicPoints = Mind
Attack = Body
Evade = Speed
Defense = 0
Range = 0
MagicAbility = Mind
MagicEvade = Presence
MagicDefense = 0
</pre>
    </dd>

<dt><b><a name="en_turn">en_turn</a>(id$, func())</b></dt>
    <dd>Sets the turn function of an Entity.  Every turn, the function and
    its arguments will be evaluated, exactly as you pass them in.  The Entity's
    id will be in the global variable 'actorid$'.  To disable the turn function,
    set it to 0.  The primary use of this is to give an Entity poisoning or
    regeneration or a "sudden death" timer, and when the effect runs out or is
    cured the turn function would be set to 0.  Returns 1.
    </dd>

<dt><b><a name="gameover">gameover</a>(win, text$)</b></dt>
    <dd>Ends the game.  If 'win' is 1, a big "WINNER!" fills the screen; if 0,
    "GAME OVER".  Below that is 'text$', which should be kept very short (you
    can fit perhaps 20 characters across), but may contain newlines.  Returns 1.
    </dd>

<dt><b><a name="gr_get_size">gr_get_size</a>(mapid$, x, y)</b></dt>
    <dd>Returns the number of things in a Grid.
    </dd>

<dt><b><a name="gr_get_terrain$">gr_get_terrain$</a>(mapid$, x, y)</b></dt>
    <dd>Returns the Terrain type for a Grid.</dd>

<dt><b><a name="gr_get_thing$">gr_get_thing$</a>(mapid$, x, y, i)</b></dt>
    <dd>Returns the id$ of the 'i'th Thing in a Grid; 'i' is 0-indexed, and must
    be less than '<code>gr_get_size(mapid$,x,y)</code>'.  Returns 1.
    </dd>

<dt><b><a name="gr_terrain">gr_terrain</a>(mapid$, x, y, terid$)</b></dt>
    <dd>Sets the Terrain type for a Grid to 'terid$'.  The Terrain must already
    exist - see 'ter_new()'.  Returns 1.</dd>

<dt><b><a name="inputdlg$">inputdlg$</a>(title$, prompt$, inittext$ {, iconfile$})</b></dt>
    <dd>Displays a dialog box with the given title, a prompt, and a text field
    with the initial value 'inittext$'.  If 'iconfile$' is specified, that image
    is shown at the top left side of the dialog (you must give the full
    filename) - this might be a system icon ("images/icons/question.gif", etc.)
    or a character's portrait.  Returns the text entered by the user, or "" if
    the user hit Cancel or left the field blank.
    </dd>

<dt><b><a name="it_dropfunc">it_dropfunc</a>(id$, func())</b></dt>
    <dd>Sets the callback function for an Item which will be called when the
    Player tries to drop the Item.  The id of the Player will be in 'actorid$',
    and the Item will be in 'targetid$'.  If the callback returns 1, the drop
    succeeds; if it returns 0, the drop will fail, the Player will still have
    the Item, and the callback should give a message explaining why the Player
    cannot drop it.  Returns 1.  Set 'func()' to 0 to disable the trigger.
    </dd>

<dt><b><a name="it_equip">it_equip</a>(id$, pos)</b></dt>
    <dd>Sets an Item to be usable as equipment in position 'pos' (one of the
    EQ_ constants defined above), or not equipment if 'pos' is -1.  Returns 1.
    </dd>

<dt><b><a name="it_equipfunc">it_equipfunc</a>(id$, func())</b></dt>
    <dd>Sets the callback function for an Item which will be called when the
    Player tries to equip the Item.  The id of the Player will be in 'actorid$',
    and the Item will be in 'targetid$'.  If the callback returns 1, the equip
    succeeds; if it returns 0, the equip will fail, the Player will still have
    the Item, and the callback should give a message explaining why the Player
    cannot equip it ("You are not strong enough!" or "You cannot hold a
    two-handed weapon and a shield at the same time!", for instance).  Returns
    1.  Set 'func()' to 0 to disable the trigger.
    </dd>

<dt><b><a name="it_new">it_new</a>(id$, name$)</b></dt>
    <dd>Creates a new Item.  Returns 1.
    </dd>

<dt><b><a name="it_removefunc">it_removefunc</a>(id$, func())</b></dt>
    <dd>Sets the callback function for an Item which will be called when the
    Player tries to remove the Item.  The id of the Player will be in
    'actorid$', and the Item will be in 'targetid$'.  If the callback returns 1,
    the remove succeeds; if it returns 0, the remove will fail, the Player will
    still have the Item, and the callback should give a message explaining why
    the Player cannot remove it ("It is cursed!", for instance).  Returns 1.
    Set 'func()' to 0 to disable the trigger.
    </dd>

<dt><b><a name="it_takefunc">it_takefunc</a>(id$, func())</b></dt>
    <dd>Sets the callback function for an Item which will be called when the
    Player tries to take the Item.  The id of the Player will be in 'actorid$',
    and the Item will be in 'targetid$'.  If the callback returns 1, the take
    succeeds; if it returns 0, the take will fail, the Player will still have
    the Item, and the callback should give a message explaining why the Player
    cannot take it ("It is too heavy for you!", for instance).  Returns 1.  Set
    'func()' to 0 to disable the trigger.
    </dd>

<dt><b><a name="map_bounds">map_bounds</a>(id$, func())</b></dt>
    <dd>Sets the bounds function of a Map.  When the Player (and only the
    Player) tries to enter the outer edge of a Map, and is not prevented by
    walls or blocking Things, this function is called.  The Player still cannot
    enter the outer edge, though.  Bounds are mostly used to return to a world
    map from towns or dungeons, or to a town from buildings.  To disable the
    bounds function, set it to 0: '<code>map_bounds(id$, 0)</code>'.  Creatures
    will not even try to enter the outer bounds of a Map.  Returns 1.
    </dd>

<dt><b><a name="map_fill">map_fill</a>(id$, x, y, &lt;str hash define&gt;, mapdata$)</b></dt>
    <dd>Fills in the terrain of the map 'id$', starting at 'x','y'.  'mapdata$'
    is split up vertically by newlines, and each character represents one grid.
    Each character is looked up in 'define' to find the terrain id; Minimal
    syntax requires an index, but it is ignored, so you should write
    '<code>define$[""]</code>'.  Spaces in 'mapdata$' are ignored - the terrain
    in those grids is unchanged.  This allows you to fill non-rectangular
    regions.  Returns 1.

    <p>For example, the following script produces the game shown in 
    <a href="../images/screenshot/binary1.png">this screenshot</a>.</p>
<pre>
def(newgame())
    ter0()
    ter1()
    map_new("binary_M", "Binary", 5, 5)
    map_fill("binary_M", 0, 0, ter$[""], join$(
        "10111\n",
        "10001\n",
        "11101\n",
        "10001\n",
        "10111\n", ) )
    th_moveto("player", "binary_M",1,1)
    ;

def(ter0())
    ter_new("ter0", "")
    ter_tile("ter0", LAYER_Under, "images/ground/grass", 1, 1)
    ter_walls("ter0", "0000")
    ter_opa("ter0", OPA_None)
    global(ter$["0"], "ter0")
    ;

def(ter1())
    ter_new("ter1", "")
    ter_tile("ter1", LAYER_Under, "images/ground/forest", 1, 1)
    ter_walls("ter1", "1111")
    ter_opa("ter1", OPA_Full)
    global(ter$["1"], "ter1")
    ;
</pre>
    </dd>

<dt><b><a name="map_get_xsize">map_get_xsize</a>(id$)</b></dt>
    <dd>Returns the horizontal size of a Map.  Because Grids are 0-indexed, this
    will be one higher than the highest Grid on the Map.  So if you want to
    cover a Map in plains, you might write:
<pre>
    let(plains$, tempid$())
    ter_new(plains$, "")
    ter_tile(plains$, 0, "images/ground/grass", 1, 1)
    for(y, 0, sub(map_get_ysize(mapid$),1), 1,
        for(x, 0, sub(map_get_xsize(mapid$),1), 1,
            gr_terrain(mapid$, x, y, plains$) ) )
</pre>
    </dd>

<dt><b><a name="map_get_ysize">map_get_ysize</a>(id$)</b></dt>
    <dd>Returns the vertical size of a Map.  See map_get_xsize().
    </dd>

<dt><b><a name="map_new">map_new</a>(id$, name$, xsize, ysize)</b></dt>
    <dd>Creates a new empty map.  Returns 1.
    </dd>

<dt><b><a name="menu">menu</a>(title$, text$, options$, cancel {, iconfile$})</b></dt>
    <dd>Displays a menu dialog, with the given 'title$' and 'text$'.  'text$'
    can contain newlines ('\n').  'options$' is a string containing the choices
    for the menu, each separated by a '|' character.  If 'cancel' is non-zero,
    a "Cancel" button will be provided.  If 'iconfile$' is specified, that image
    is shown at the top left side of the dialog (you must give the full
    filename) - this might be a system icon ("images/icons/question.gif", etc.)
    or a character's portrait.    Returns the index (1-based) of the button
    chosen, or 0 if "Cancel" was chosen.
    </dd>

<dt><b><a name="output">output</a>(&lt;any a&gt;,,,)</b></dt>
    <dd>Joins together all 'a', and displays it in the output area.  Returns 1.
    </dd>

<dt><b><a name="outputicon">outputicon</a>(icon$, &lt;any b&gt;,,,)</b></dt>
    <dd>Joins together all 'b', and displays it in the output area with image
    file 'icon$' to the left.  'icon$' must be the full filename, not just the
    basename - "images/item/gold_0n.gif", for instance.  Returns 1.
    </dd>

<dt><b><a name="output_color">output_color</a>(fg$, bg$)</b></dt>
    <dd>Changes the foreground and background colors of the output window.  The
    colors are the same as listed below for
    '<code><a href="#gcolor">gcolor()</a></code>'.  Red (#ff0000) and blue
    (#0000ff) are used by combat and error messages, so you should always choose
    output colors that will leave those visible - either a dark background or a
    light one, or a green one, but do not use a pure blue or red output
    background.  Returns 1.</dd>

<dt><b><a name="pause">pause</a>()</b></dt>
    <dd>"Pauses" the map view.  When the map view is paused, it will not
    automatically redraw until you tell it to with a redraw(), or until you tell
    it to resume().  You must <b>always</b> resume() after pausing.  Returns 1.
    This is most often used in animated intro sequences:
<pre>
def(intro())
    pause()
    th_moveto("player", "world_M",5,0)
    redraw()
    wait(0.5)
    th_moveto("player", "world_M",5,1)
    redraw()
    wait(0.5)
    th_moveto("player", "world_M",5,2)
    redraw()
    wait(0.5)
    th_moveto("player", "world_M",5,3)
    redraw()
    wait(0.5)
    th_moveto("player", "world_M",5,4)
    redraw()
    wait(0.5)
    th_moveto("player", "world_M",5,5)
    resume()
    ;
</pre>
    </dd>

<dt><b><a name="pl_drop">pl_drop</a>(plid$, itid$)</b></dt>
    <dd>The player drops an item 'itid$' from inventory to the ground.  'plid$'
    should always be "player" (it is included for compatibility with future
    versions which may allow multi-character parties).  Returns 1 if the drop
    succeeded, 0 if it failed, which can happen if you've set '<code><a
    href="#it_dropfunc">it_dropfunc()</a></code>'.
    </dd>

<dt><b><a name="pl_equip">pl_equip</a>(plid$, itid$)</b></dt>
    <dd>The player equips an item 'itid$' from inventory, first removing any
    equipment in the same position.  'plid$' should always be "player".  Returns
    1 if the equip succeeded, 0 if it failed, which can happen if you've set
    '<code><a href="#it_equip">it_equipfunc()</a></code>'.
    </dd>

<dt><b><a name="pl_get_equip$">pl_get_equip$</a>(plid$, pos)</b></dt>
    <dd>Returns the id$ of an equipment item of the Player; 'pos' is one of the
    EQ_* constants above.  Returns "" if no item is ready there.
    </dd>

<dt><b><a name="pl_get_item$">pl_get_item$</a>(plid$, i)</b></dt>
    <dd>Returns the id$ of the 'i'th item carried by Player; 'i' is 0-indexed,
    and must be less than '<code>pl_get_item_count(plid$)</code>'.
    </dd>

<dt><b><a name="pl_get_item_count">pl_get_item_count</a>(plid$)</b></dt>
    <dd>Returns the number of items carried by the Player.  'plid$' should
    always be "player".  Returns 1.
    </dd>

<dt><b><a name="pl_get_level">pl_get_level</a>(plid$)</b></dt>
    <dd>Returns the Player's current level.  There is no way to change the level
    except to give the Player more experience.
    </dd>

<dt><b><a name="pl_remove">pl_remove</a>(plid$, pos)</b></dt>
    <dd>The player removes equipment from 'pos', which must be one of EQ_*, and
    returns it to inventory.  'plid$' should always be "player".  Returns 1 if
    the remove succeeded, 0 if it failed, which can happen if you've set
    '<code><a href="#it_removefunc">it_removefunc()</a></code>'.
    </dd>

<dt><b><a name="pl_take">pl_take</a>(plid$, itid$)</b></dt>
    <dd>The player takes an item 'itid$', which may have any location.  'plid$'
    should always be "player".  Returns 1 if the take succeeded, 0 if it failed,
    which can happen if you've set
    '<code><a href="#it_takefunc">it_takefunc()</a></code>'.
    </dd>

<dt><b><a name="playsound">playsound</a>(filename$ {, control})</b></dt>
    <dd>Plays a sound file.  'filename$' is the path relative to Hephaestus,
    including the extension (usually ".au" or ".wav"), and always uses '/'
    between paths (even if you're using Windows).  If 'control' is included, it
    can have one of three values: SOUND_Loop, to play the sound looping over and
    over; SOUND_Stop, to stop the named sound, if it's currently playing; or
    SOUND_StopAll, to stop all sounds in the engine.  See
    <a href="sound.html">Sound</a>.  Returns 1.
    </dd>

<dt><b><a name="redraw">redraw</a>()</b></dt>
    <dd>Forces the map view to update right now.  See pause().  Returns 1.
    </dd>

<dt><b><a name="resume">resume</a>()</b></dt>
    <dd>"Resumes" the map view, so it will update normally.  See pause().
    Returns 1.
    </dd>

<dt><b><a name="stats_lock">stats_lock</a>(a)</b></dt>
    <dd>If 'a' is non-zero, locks the stats display so you can make multiple
    changes as a single update, without the display flickering.  When you get
    done with your changes, call again with 'a' as 0 to unlock it.  Returns 1.
    </dd>

<dt><b><a name="st_exists">st_exists</a>(id$)</b></dt>
    <dd>Returns 0 if Stuff 'id$' does not exist, or one of the TYPE_* constants
    if it does.  As other types may be added in the
    future, you should always have an 'else' case in any test involving the
    type, for instance:
<pre>
let(type,st_exists(targetid$))
if(eq(type,0),return("Nothing"),
    eq(type,TYPE_Map),return("Map"),
    eq(type,TYPE_Item),return("Item"),
    eq(type,TYPE_Creature),return("Creature"),
    eq(type,TYPE_Player),return("Player"),
    return("Unknown") )
</pre>
    </dd>

<dt><b><a name="st_get_name$">st_get_name$</a>(id$)</b></dt>
    <dd>Returns the name of a Stuff.
    </dd>

<dt><b><a name="st_get_prop">st_get_prop</a>(id$, key$)</b></dt>
<dt><b><a name="st_get_prop$">st_get_prop$</a>(id$, key$)</b></dt>
    <dd>Returns the value of property 'key$' assigned to a Stuff.  If you try
    to read a property which has not been set, returns 0 for 'st_get_prop' or
    "" for 'st_get_prop$'.  If you try to read a property which is of a
    different type than the function (string for 'st_get_prop' or number for
    'st_get_prop$'), an error occurs.  See also 'st_prop'.
    </dd>

<dt><b><a name="st_name">st_name</a>(id$, name$)</b></dt>
    <dd>Changes the name of a Stuff.  Returns 1.
    </dd>

<dt><b><a name="st_prop">st_prop</a>(id$, key$, &lt;any value&gt;)</b></dt>
    <dd>Sets the value of property 'key$' on Stuff 'id$' to 'value'.
    Properties can be used for any values of your own, and read with
    'st_get_prop'.  These let you expand the capabilities of the system almost
    indefinitely.  The main uses are as status flags, or to hold lists of items
    for shopkeepers or creatures with predefined loot (use a property like
    "nitems" to hold the number of items, and '<code>join$("item",i)</code>' to
    identify each item).  Returns 1.
    </dd>

<dt><b><a name="st_trigger">st_trigger</a>(id$, func())</b></dt>
    <dd>Sets the trigger function of a Stuff.  If the target is a Map, then it
    is triggered every turn that the player is on it; if it is a Thing, it is
    triggered when the user runs into it or hits "trigger" on it; if it is a
    Terrain, it is triggered when the user tries to enter it.

    <p>When triggered, the function and its arguments will be evaluated, exactly
    as you pass them in (function arguments are not evaluated until the
    triggering event, but variables are immediately evaluated).  If you want to
    disable the trigger, set it to 0.  The id of the Thing triggered will be in
    the global variable 'targetid$', and the id of the Entity that triggered it
    will be in 'actorid$', which you can test to separate the Player from
    Creatures.</p>

    <p>If the target is a Terrain, then the return value of the trigger function
    matters - zero indicates that the actor cannot enter the grid, non-zero
    indicates that the actor can.  The return value does not matter for other
    targets.</p>

    <p>Returns 1.</p>
    </dd>

<dt><b><a name="tempid$">tempid$</a>()</b></dt>
    <dd>Returns a random temporary id, guaranteed not to clash with anything
    currently defined; it is in the form "_1", etc.; users should never create
    an id starting with an underscore.  tempid$() is mostly used when you're
    generating terrain, equipment items, or blocks that you never expect to
    refer to by id again.  Or you can store the id in a global variable.
    </dd>

<dt><b><a name="ter_frame">ter_frame</a>(id$, layer, frame)</b></dt>
    <dd>Sets the current frame of a Terrain.  'layer' is LAYER_Under or
    LAYER_Over.  This is used for the same reason as 'th_frame' - it can be
    used to produce the effect of waves lapping at a shore, if every tile on
    the same row or column is given the same frame, then the next frame for the
    next row or column, etc.  Returns 1.
    </dd>

<dt><b><a name="ter_get_tile$">ter_get_tile$</a>(id$, layer)</b></dt>
    <dd>Returns the 'basefile$' of a Terrain layer's tile, used to identify the
    type of terrain an Entity is on.
    </dd>

<dt><b><a name="ter_get_walls$">ter_get_walls$</a>(id$)</b></dt>
    <dd>Returns the walls of a Terrain; see 'ter_walls()' for the format.
    </dd>

<dt><b><a name="ter_new">ter_new</a>(id$, name$)</b></dt>
    <dd>Creates a new Terrain.  Returns 1.  The recommended way to work with
    terrains is to get a temporary id with
    '<code><a href="#tempid$">tempid$()</a></code>', build the terrain, and
    then assign it to the grids, either directly (shown in the example below) or
    with '<code><a href="#map_fill">map_fill()</a></code>':
<pre>
def(build_elysium())
    map_new("elysium","Elysium",11,11)
    let(grass$, tempid$())
    ter_new(grass$, "")
    ter_tile(grass$, LAYER_Under, "images/ground/grass", 1, 1)
    for(y,0,10,1, for(x,0,10,1, gr_terrain("elysium",x,y, grass$) ) )
    let(flower$, tempid$())
    ter_new(flower$, "")
    ter_tile(flower$, LAYER_Under, "images/ground/dandelions", 1, 1)
    for(i,1,20,1,
        let(x,sub(rnd(11),1)), let(y,sub(rnd(11),1)),
        gr_terrain("elysium",x,y, flower$)
    )
    ;
</pre>
    </dd>

<dt><b><a name="ter_opa">ter_opa</a>(id$, opa)</b></dt>
    <dd>Sets the opacity of a Terrain: OPA_None (you can see through it),
    OPA_Partial (there's a "mist" over everything behind it, and you can't see
    through two partials), OPA_Full (you can't see through it).  Returns 1.
    </dd>

<dt><b><a name="ter_tile">ter_tile</a>(id$, layer, basefile$, nfacings, nframes)</b></dt>
    <dd>Assigns a new tile to a Terrain.  'layer' is LAYER_Under or LAYER_Over;
    'basefile$' is the path relative to Hephaestus - see
    <a href="art.html">Art</a>.  'nfacings' must be 1, 2, or 4;
    'nframes' must be 1 or more, the latter two depend on the image files
    available.  Returns 1.
    </dd>

<dt><b><a name="ter_walls">ter_walls</a>(id$, walls$)</b></dt>
    <dd>Sets the walls of a Terrain.  'walls$' must be 4 characters,
    representing N, E, S, W in order, each one 0=no wall, or 1=wall; all
    Terrains start as "0000".  Walls aren't just physical walls, either - ledges
    that you can't ascend or descend and catwalks can be built with walls, for
    instance.  Walls block both entry and exit from the terrain.  Returns 1.
    </dd>

<dt><b><a name="th_blocking">th_blocking</a>(id$, state)</b></dt>
    <dd>Sets the blocking state of a Thing; 0=non-blocking, non-zero=blocking.
    The default for Items is non-blocking, for all other types is blocking.  Any
    non-blocking Item can be picked up and carried by the Player.  Returns 1.
    </dd>

<dt><b><a name="th_frame">th_frame</a>(id$, frame)</b></dt>
    <dd>Sets the starting frame of a Thing.  This is only really useful when
    creating animation sequences with multiple Things using the same tile; if
    you just create them all with the same frame, they'll appear to be doing
    synchronized jumping jacks or something, which is very silly-looking.
    Returns 1.
    </dd>

<dt><b><a name="th_facing">th_facing</a>(id$, facing)</b></dt>
    <dd>Sets the facing of a Thing; 0=North, 1=East, 2=South, 3=West.  Returns
    1.
    </dd>

<dt><b><a name="th_get_facing">th_get_facing</a>(id$)</b></dt>
    <dd>Returns the facing of a Thing; 0=North, 1=East, 2=South, 3=West.
    </dd>

<dt><b><a name="th_get_gold">th_get_gold</a>(id$)</b></dt>
    <dd>Returns the gold of a Thing.  Only works on Statted things - Items or
    Entities.
    </dd>

<dt><b><a name="th_get_mapid$">th_get_mapid$</a>(id$)</b></dt>
    <dd>Returns the map id of a Thing's current location.
    </dd>

<dt><b><a name="th_get_pose">th_get_pose</a>(id$)</b></dt>
    <dd>Returns the current pose of a Thing.
    </dd>

<dt><b><a name="th_get_stat">th_get_stat</a>(id$, stat)</b></dt>
    <dd>Returns the current stat score of a Thing for 'stat'.  Only works on
    Statted things - Items or Entities.
    </dd>

<dt><b><a name="th_get_statmax">th_get_statmax</a>(id$, stat)</b></dt>
    <dd>Returns the maximum stat score of a Thing for 'stat'.  Only works on
    Statted things - Items or Entities.
    </dd>

<dt><b><a name="th_get_sx">th_get_sx</a>(id$)</b></dt>
    <dd>Returns the leftmost x-coord of a Thing on the screen for use with <a
    href="#graphics_functions">graphics functions</a>.  If the coord is less
    than 0 or greater than VIEW_SIZE, then the Thing is not visible.
    </dd>

<dt><b><a name="th_get_sy">th_get_sy</a>(id$)</b></dt>
    <dd>Returns the topmost y-coord of a Thing on the screen for use with <a
    href="#graphics_functions">graphics functions</a>.  If the coord is less
    than 0 or greater than VIEW_SIZE, then the Thing is not visible.  This is
    the top of the grid square, NOT the top of the tile.  If the tile is 70
    pixels tall, for instance, it will extend 22 pixels above 'th_get_sy()'.
    </dd>

<dt><b><a name="th_get_x">th_get_x</a>(id$)</b></dt>
    <dd>Returns the x-coord of a Thing's current location.
    </dd>

<dt><b><a name="th_get_y">th_get_y</a>(id$)</b></dt>
    <dd>Returns the y-coord of a Thing's current location.
    </dd>

<dt><b><a name="th_gold">th_gold</a>(id$, gold)</b></dt>
    <dd>Sets the gold of a Thing.  Creature gold is used as a reward when
    defeated by the Player.  Player gold is the current cash carried, which can
    be spent to buy items and services.  Item gold is used as the price to buy
    the Item new (Items are worth half as much when sold).  Naturally, all game
    worlds use gold as their currency, just as all alternate history worlds have
    fleets of zeppelins.  Returns 1.  Only works on Statted things - Items or
    Entities.
    </dd>

<dt><b><a name="th_moveto">th_moveto</a>(id$, mapid$, x, y {, teleport }?)</b></dt>
    <dd>Moves a Thing to a new Grid.  If 'teleport' is specified and non-zero,
    the trigger (see 'st_trigger()') of the destination grid is not checked.
    For instance, in Hades, the stairs "teleport" the player onto the next
    level's stairs; if they did not, the player would bounce up and down forever
    as each stair's trigger activated.  Returns 1 if the move was successful, 0
    if it failed.
    </dd>

<dt><b><a name="th_opa">th_opa</a>(id$, opa)</b></dt>
    <dd>Sets the opacity of Thing 'id$'.  The default opacity of all Things is
    OPA_None.  Returns 1.
    </dd>

<dt><b><a name="th_pose">th_pose</a>(id$, pose)</b></dt>
    <dd>Sets the pose of a Thing (0-indexed).  Returns 1.
    </dd>

<dt><b><a name="th_remove">th_remove</a>(id$, destroy)</b></dt>
    <dd>Removes a Thing from the map, and destroys it if destroy is non-zero.
    Returns 1.
    </dd>

<dt><b><a name="th_stat">th_stat</a>(id$, stat, score)</b></dt>
    <dd>Sets the current stat score of a Thing for 'stat' to 'score'.  If you
    set the current stat higher than the maximum, it is cut off at the max.
    Entities use their stats directly, while the stats of Items are added to the
    stats of a Player who equips that Items, and subtracted again when the Item
    is unequipped.  Only works on Statted things - Items or Entities.
    </dd>

<dt><b><a name="th_statmax">th_statmax</a>(id$, stat, score)</b></dt>
    <dd>Sets the maximum stat score of a Thing for 'stat' to 'score'.  If you
    set the maximum stat lower than the current stat, the current stat is also
    lowered.  Only works on Statted things - Items or Entities.
    </dd>

<dt><b><a name="th_statboth">th_statboth</a>(id$, stat, score)</b></dt>
    <dd>Sets both the current and maximum stat score of a Thing for 'stat' to
    'score'.  Only works on Statted things - Items or Entities.
    </dd>

<dt><b><a name="th_task">th_task</a>(id$, stat)</b></dt>
    <dd>Returns the result of Thing 'id$' attempting a task against a given
    'stat'.  This is a 'dXX' roll (roll 2d10, if 2 is rolled, roll again and
    subtract, if 20 is rolled, roll again and add), plus the stat, minus 20 (the
    basic target number).  A positive result is a success (unless you want to
    make it more difficult), a zero or negative result is a failure.  The roll
    will not exceed twice the stat in either direction.  Because 2d10 has a
    bell-shaped probability curve (highest in the center, curving down to 1%
    at the ends) even a moderate bonus or penalty can make a big difference, but
    on average a +/-1 modifier is +/-5% chance of success.  Only works on
    Statted things - Items or Entities.
    </dd>

<dt><b><a name="th_tile">th_tile</a>(id$, pose, basefile$, nfacings, nframes)</b></dt>
    <dd>Assigns a new tile to a thing's pose.  'basefile$' is the path relative
    to Hephaestus - see <a href="art.html">Art</a>.  'nfacings' must be
    1, 2, or 4; 'nframes' must be 1 or more, the latter two depend on the image
    files available.  When first defining a Thing, be sure to define the poses
    in order.  If you want to remove a tile, set 'basefile$' to "".  Returns 1.
    </dd>

<dt><b><a name="wait">wait</a>(a)</b></dt>
    <dd>Waits for 'a' seconds, which may be fractional, and then returns.
    Mostly used as a delay in animation sequences, see pause().  Returns 1.
    </dd>

<dt><b><a name="window_color">window_color</a>(fg$, bg$)</b></dt>
    <dd>Changes the foreground and background colors of the game window.  The
    colors are the same as listed below for
    '<code><a href="#gcolor">gcolor()</a></code>'.  This will make the menu bar
    flash in and out of existence, an unfortunate problem with Java's windowing
    toolkit.  Returns 1.</dd>

<dt><b><a name="window_image">window_image</a>(filename$)</b></dt>
    <dd>Changes the tiled background image of the lower left corner of the game
    window.  Note that this is not aligned with the bottom of the output, and
    its positioning will vary on different platforms, or even the same platform
    with different fonts, so don't rely on the image being lined up wherever it
    is on your screen, use it more like a web page background.  Returns 1.</dd>

</dl>

<p><hr noshade="noshade" size="2" /></p>
<h2><a name="graphics_functions">Graphics Functions</a></h2>
<p>The mdh.hephaestus.graphics library is automatically loaded when you start
Hephaestus.</p>

<p>The graphics functions allow you to draw freeform graphics on top of the
display.  The main use for this is for special effects and illustrating
attacks, or for use in "cinematic" sequences.  The drawings are not shown until
you issue a redraw() command (or the view updates for the next turn), and remain
until you issue a gcls() command.</p>

<p>The display is VIEW_SIZE pixels across and down, and coords are
0-indexed.</p>

<p>Graphics functions use an invisible "cursor" position, rather than passing
the start coordinate in each time.  To draw a line from 10,5 to 100,50, you
gmove(10,5) to the start of the line, then gline(100,50) to the end of the
line; afterwards, the cursor will be at 100,50.</p>

<h3>Example</h3>
<p>Call the following function, and the player will be "targeted" with four
yellow lines from the corners and a red box; if you put this in a map's
'st_trigger' function, the player will be constantly targeted.</p>

<pre>
def(targeting())
    # find the top-left corner of the player's grid
    let(x, mul(th_get_x("player"),TILE_SIZE))
    let(y, mul(th_get_y("player"),TILE_SIZE))
    # offset to the center of the player's image, which is 48x70
    addv(x, 24)  # 48/2 = 24
    addv(y, 11)  # (70-48)/2 = 11
    gcls()
    gcolor("yellow")
    gplot(0,0)
    gline(x,y)
    gline(VIEW_SIZE,0)
    gplot(0,VIEW_SIZE)
    gline(x,y)
    gline(VIEW_SIZE,VIEW_SIZE)
    gcolor("red")
    gmove(sub(x,24), sub(y,35))
    grect(add(x,24), add(y,35))
    redraw()
    ;
</pre>

<dl>
<dt><b><a name="gcls">gcls</a>()</b></dt>
    <dd>Clears the graphics pane.  Returns 1.</dd>

<dt><b><a name="gcolor">gcolor</a>(c$)</b></dt>
    <dd>Sets the current color to the color code 'c'.  'c' may be one of the
    folowing named colors, or "web format" ("#RRGGBB").  Returns 1.
    <table>
    <tr><th align="left">Name</th>	<th align="left">Web Format</th>	<th align="left">Color Test</th></tr>
    <tr><td>black</td>	<td><tt>#000000</tt></td>	<td bgcolor="#000000">&nbsp;&nbsp;&nbsp;</td></tr>
    <tr><td>blue</td>	<td><tt>#0000ff</tt></td>	<td bgcolor="#0000ff">&nbsp;&nbsp;&nbsp;</td></tr>
    <tr><td>cyan</td>	<td><tt>#00ffff</tt></td>	<td bgcolor="#00ffff">&nbsp;&nbsp;&nbsp;</td></tr>
    <tr><td>darkGray</td>	<td><tt>#404040</tt></td>	<td bgcolor="#404040">&nbsp;&nbsp;&nbsp;</td></tr>
    <tr><td>gray</td>	<td><tt>#808080</tt></td>	<td bgcolor="#808080">&nbsp;&nbsp;&nbsp;</td></tr>
    <tr><td>green</td>	<td><tt>#00ff00</tt></td>	<td bgcolor="#00ff00">&nbsp;&nbsp;&nbsp;</td></tr>
    <tr><td>lightGray</td>	<td><tt>#c0c0c0</tt></td>	<td bgcolor="#c0c0c0">&nbsp;&nbsp;&nbsp;</td></tr>
    <tr><td>magenta</td>	<td><tt>#ff00ff</tt></td>	<td bgcolor="#ff00ff">&nbsp;&nbsp;&nbsp;</td></tr>
    <tr><td>orange</td>	<td><tt>#ffc800</tt></td>	<td bgcolor="#ffc800">&nbsp;&nbsp;&nbsp;</td></tr>
    <tr><td>pink</td>	<td><tt>#ffafaf</tt></td>	<td bgcolor="#ffafaf">&nbsp;&nbsp;&nbsp;</td></tr>
    <tr><td>red</td>	<td><tt>#ff0000</tt></td>	<td bgcolor="#ff0000">&nbsp;&nbsp;&nbsp;</td></tr>
    <tr><td>white</td>	<td><tt>#ffffff</tt></td>	<td bgcolor="#ffffff">&nbsp;&nbsp;&nbsp;</td></tr>
    <tr><td>yellow</td>	<td><tt>#ffff00</tt></td>	<td bgcolor="#ffff00">&nbsp;&nbsp;&nbsp;</td></tr>
    </table>

    <p>'gcolor()' also supports alpha-blending, aka "partial transparency".  By
    using the format "#aarrggbb", the hex number in "aa" is the alpha level.  A
    value of "00" or "ff" means that the color is completely opaque; a value of
    "01" means that the color is almost, but not quite, completely transparent;
    intermediate values are blended between the drawn color and the background
    color.  For instance, "#7fff0000" will tint red everything it is drawn
    over.</p>
    </dd>

<dt><b><a name="gcurx">gcurx</a>()</b></dt>
    <dd>Returns the x-coord of the cursor.
    </dd>

<dt><b><a name="gcury">gcury</a>()</b></dt>
    <dd>Returns the y-coord of the cursor.
    </dd>

<dt><b><a name="gfilloval">gfilloval</a>(x, y)</b></dt>
    <dd>Fills an oval (as 'goval') with the current color, and moves the cursor
    to 'x','y'.  Returns 1.
    </dd>

<dt><b><a name="gfillrect">gfillrect</a>(x, y)</b></dt>
    <dd>Fills the region on the graphics window from the cursor to 'x','y' with
    the current color, and moves the cursor to 'x','y'.  Returns 1.
    </dd>

<dt><b><a name="gfont">gfont</a>(a$, b$, c)</b></dt>
    <dd>Sets the font to family 'a$' ("Serif", "SansSerif", or "Monospaced"),
    style 'b$' ("p"=plain, "b"=bold, "i"=italic, "bi"="bold+italic"), and size
    'c'.  An error occurs if you give illegal values.  Returns 1.
    </dd>

<dt><b><a name="gimage">gimage</a>(filename$ {, w, h {, sx, sy, sw, sh} })</b></dt>
    <dd>Draws an image on the graphics screen at the cursor.  If w,h are
    specified, the image is scaled to that width and height.  If sx,sy,sw,sh are
    specified, only a subsection of the image is drawn and scaled.  Returns 1.
    </dd>

<dt><b><a name="gline">gline</a>(x, y)</b></dt>
    <dd>Draws a line on the graphics screen from the cursor to 'x','y', and
    moves the cursor there.  Returns 1.
    </dd>

<dt><b><a name="gmove">gmove</a>(x, y)</b></dt>
    <dd>Moves the cursor to 'x','y' without painting anything.  Returns 1.
    </dd>

<dt><b><a name="goval">goval</a>(x, y)</b></dt>
    <dd>Draws an oval on the graphics screen from the cursor to 'x','y', and
    moves the cursor there.  Returns 1.
    </dd>

<dt><b><a name="gplot">gplot</a>(x, y)</b></dt>
    <dd>Draws a pixel on the graphics screen at 'x','y' and moves the cursor
    there.  Returns 1.
    </dd>

<dt><b><a name="grect">grect</a>(x, y)</b></dt>
    <dd>Draws a rectangle on the graphics screen from the cursor to 'x','y', and
    moves the cursor there.  Returns 1.
    </dd>

<dt><b><a name="gtext">gtext</a>(a$)</b></dt>
    <dd>Draws text 'a' on the graphics window at the cursor (top left corner of
    the text), in the current font and color, and moves the cursor to
    immediately after the text, or to the start of the next "line" if the
    cursor is off the screen.  Returns 1.
    </dd>

<dt><b><a name="gtext_height">gtext_height</a>(a$)</b></dt>
    <dd>Returns the height of text 'a' in pixels.
    </dd>

<dt><b><a name="gtext_width">gtext_width</a>(a$)</b></dt>
    <dd>Returns the width of text 'a' in pixels.
    </dd>

</dl>


<!--
<dt><b><a name="x">x</a>()</b></dt>
    <dd>x.  Returns 1.
    </dd>

-->
<hr />EOF
</body>
</html>
